# Blog Topics: Swift Language

## Beginner Swift

1. **Optionals explained simply** - Why they exist, unwrapping safely
2. **if let vs guard let** - When to use which
3. **Structs vs Classes** - Value vs reference types
4. **Arrays, Sets, Dictionaries** - Collection basics
5. **For loops and iterations** - forEach, enumerated, indices
6. **Functions and closures intro** - Syntax, trailing closures
7. **Enums with associated values** - Powerful pattern matching
8. **Properties: stored vs computed** - Getters, setters, didSet
9. **Access control basics** - private, fileprivate, internal, public
10. **Error handling with try/catch** - Throwing functions

## Intermediate Swift

11. **Protocols explained** - Conformance, default implementations
12. **Extensions: Adding functionality** - Retroactive modeling
13. **Generics basics** - Type parameters, constraints
14. **Closures deep dive** - Capture lists, escaping, autoclosure
15. **map, filter, reduce explained** - Functional patterns
16. **compactMap vs flatMap** - When to use which
17. **Codable for JSON parsing** - Encode, decode, custom keys
18. **Property wrappers basics** - @propertyWrapper, projectedValue
19. **Lazy properties and sequences** - Deferred evaluation
20. **Subscripts: Custom accessors** - Array-like syntax for types

## Advanced Swift

21. **Protocol-oriented programming** - Composition over inheritance
22. **Generics: where clauses and associated types** - Advanced constraints
23. **Opaque types (some) explained** - When and why
24. **Result builders deep dive** - Building DSLs
25. **Key paths and their uses** - Dynamic member lookup
26. **Copy-on-write implementation** - Performance optimization
27. **Memory management: ARC internals** - Strong, weak, unowned
28. **Metatypes: .self and .Type** - Runtime type access
29. **@dynamicCallable and @dynamicMemberLookup** - Scripting language interop
30. **Unsafe Swift: Pointers and buffers** - When you need raw performance

## Swift Concurrency

31. **async/await basics** - Simple async code
32. **Task and TaskGroup** - Structured concurrency
33. **Actors explained** - Data race prevention
34. **MainActor for UI updates** - Thread safety
35. **AsyncSequence and AsyncStream** - Async iteration
36. **Continuations: Bridging old APIs** - withCheckedContinuation
37. **Sendable protocol** - Safe data sharing
38. **Task cancellation done right** - Cooperative cancellation
39. **Actor isolation explained** - nonisolated, isolated parameters
40. **Global actors: Custom actors** - Beyond MainActor

## Swift 5.9/6.0 Features

41. **Macros in Swift** - #stringify, custom macros
42. **if/switch expressions** - Returning values
43. **Consume and borrowing** - Ownership keywords
44. **Noncopyable types** - ~Copyable structs
45. **Parameter packs** - Variadic generics
46. **Typed throws** - Specific error types
47. **Strict concurrency checking** - Migration guide
48. **@retroactive conformance** - Silencing warnings properly
49. **Observation framework** - @Observable under the hood
50. **Swift Testing framework** - #expect, @Test basics

## High-Traffic Swift Searches

51. **"Cannot convert value of type"** - Type mismatch fixes
52. **"Escaping closure captures mutating self"** - Solutions
53. **"Protocol can only be used as a generic constraint"** - any vs some
54. **String to Int conversion** - Parsing safely
55. **Date formatting in Swift** - DateFormatter, ISO8601
56. **Comparing optionals** - Nil coalescing, equality
57. **Sorting arrays of objects** - sorted(by:), Comparable
58. **Removing duplicates from array** - Set, filter patterns
59. **Delay/sleep in Swift** - Task.sleep, DispatchQueue
60. **Reading/writing files in Swift** - FileManager basics

## Patterns & Best Practices

61. **Dependency injection without frameworks** - Protocol-based DI
62. **Builder pattern in Swift** - Fluent interfaces
63. **Factory pattern with protocols** - Flexible object creation
64. **Singleton: When it's actually okay** - And when it's not
65. **Result type for error handling** - Beyond throws
66. **Type erasure explained** - AnyPublisher, AnySequence
67. **Phantom types for safety** - Compile-time guarantees
68. **Never type and its uses** - Impossible states
69. **ExpressibleBy protocols** - Literal convertibles
70. **Custom operators: When to use** - Readability considerations
